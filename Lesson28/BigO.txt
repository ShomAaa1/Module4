1.Алгоритм проверки наличия дубликатов в массиве.
Внешний цикл – n итераций (где n = len(arr)). Внутренний цикл в среднем выполняется (n – I – 1) раз. Общее количество сравнений: (n-1) + (n-2)+ … + 1 = n*(n-1)/2.
Это О(n2) по времени в худшем случае.
Факторы, влияющие на производительность. В практических условиях скорость будет зависеть от:
- расположения дубликатов. Если дубликат найден рано, то алгоритм быстро завершится.
- размер входных данных. При n в десятки тысяч квадратичный рост приведет к долгому выполнению.
- скорость сравнения элементов. Для простых типов сравнение быстрое.
- архитектура и кэш-память процессора. Если массив большой и не помещается в кэш, доступ к элементам будет медленнее.
Чтобы уменьшить время работы до О(n) в худшем случаем, можно использовать set.

2.Алгоритм поиска максимального элемента в неотсортированном массиве.
Один цикл. Количество итераций цикла всегда = n (длина массива). В каждой итерации выполняется постоянное количество операций (одно сравнение, возможно присваивание). Значит, общее время работы Т = с * n.
Временная сложность – О(n).
Факторы, влияющие на производительность на практике:
- размер входных данных
- тип элементов и операция сравнения
- аппаратные факторы

3.Алгоритм сортировки выбором
Внешний цикл – n итераций (где n = len(arr)). Внутренний цикл в среднем выполняется (n – I – 1) раз. Общее количество сравнений: (n-1) + (n-2)+ … + 1 = n*(n-1)/2.
Это О(n2) по времени в любом случае.
Факторы, влияющие на производительность на практике: размер массива, стоимость сравнения, стоимость обмена, аппаратные особенности.

4.Алгоритм быстрой сортировки
Средний случай.
Каждый раз мы делим массив примерно пополам. На каждом уровне рекурсии обрабатывается n элементов. Глубина рекурсии примерно = log2n. T = n * logn.
Сложность: О(n log n).
Худший случай.
Если опорный элемент выбран неудачно, то один подмассив будет почти пустой, а другой почти такой же, как исходный. Глубина рекурсии становится n. Формула: Т(n) = n * n
Сложность О(n2).
Факторы, влияющие на производительность: выбор опорного элемента, тип данных, размер массива.

5.Алгоритм вычисления n-го числа Фибоначчи (рекурсивно).
Дерево рекурсии. Для n функция вызывает две копии себя: f(n-1) и f(n-2). Каждая из этих копий тоже вызывает две свои, и так далее. Это создает рекурсивное дерево почти полной бинарной формы. При каждом шаге создаются два новых вызова. Глубина примерно n (так как уменьшаем аргумент на 1 или 2). Количество узлов в бинарном дереве = 2n.
Сложность О(2n).
Факторы, влияющие на производительность:
- одни и те же значения вычисляются по многу раз
- время растет экспоненциально, и уже при n>40 алгоритм становится непрактичным.






